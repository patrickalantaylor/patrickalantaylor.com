<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kubernetes vs. Serverless: | Writing from Patrick Taylor, Technology Architect and Evangelist</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <a href="/"><h1>Patrick Alan Taylor</h1></a>

  </head>

  <body>
    <nav>
    <ul class="menu">
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">Kubernetes vs. Serverless:</span></h1>

<h2 class="date">2023/06/08</h2>
</div>

<main>
<h3 id="kubernetes-vs-serverless-which-is-best-for-your-applications">Kubernetes vs. Serverless: Which Is Best For Your Applications?</h3>
<p>Microservice development has been around for some time and only continues to improve in popularity due to its flexibility and natural ability to accommodate scale.</p>
<p>Containers are a great way to run microservices and Kubernetes (often abbreviated as k8s) and Docker are the clear favorites. Developers build their containers in Docker on the laptop and DevOps deploys the same to the k8s cluster in the cloud.</p>
<p>But there are growing questions around Serverless functions like Lambda and Azure Functions. They feel like they can do the same thing as containers, but with less overhead.</p>
<h3 id="what-are-orchestrated-containers">What are orchestrated containers?</h3>
<p>Kubernetes is the most popular method of coordinating multiple containers in a server environment. Generally, this activity is referred to as “Container Orchestration,” and includes Kubernetes, Elastic Container Service, Docker Swarm, Hashicorp Nomad, and managed Kubernetes services like Amazon EKS and Azure AKS.</p>
<h3 id="choosing-between-containerized--serverless">Choosing Between Containerized &amp; Serverless</h3>
<p>At AIM Consulting, we have built dozens of software systems in high-performance, high-complexity, mission-critical applications.</p>
<p>Our clients are Fortune 200 companies doing millions of dollars of business every day, mid-size companies looking to compete and grow, and startups racing to get their ideas into the marketplace ahead of the competition. We build multi-tier web applications, internet-facing APIs, and system integrations in Java, C#, Python, and JavaScript across the major cloud providers.</p>
<p>When developing these applications, teams must choose between the use of orchestrated containers or serverless functions in order to write their logic. Both have advantages and robust communities around them.</p>
<h4 id="things-to-know-about-serverless-vs-containerized-for-high-value-applications">Things to know about Serverless vs. Containerized for High-Value Applications:</h4>
<ul>
<li>Architectural Advantages</li>
<li>Coding Style</li>
<li>Platform Knowledge</li>
<li>Data and State</li>
<li>Environment Management</li>
<li>Operational Support</li>
</ul>
<h3 id="architectural-advantages-of-orchestrated-containers-vs-serverless-functions">Architectural Advantages of Orchestrated Containers vs. Serverless Functions</h3>
<p>Many articles have been written about the architectural advantages of both serverless functions and orchestrated containers. Some of the topics these articles cover are:</p>
<table>
  <thead>
      <tr>
          <th>Orchestrated Containers</th>
          <th>(k8s)	Serverless Functions</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Better for consistent loads</td>
          <td>Better for variable loads</td>
      </tr>
      <tr>
          <td>More control</td>
          <td>Never think about servers</td>
      </tr>
      <tr>
          <td>Any language you choose</td>
          <td>Natively supports many languages</td>
      </tr>
      <tr>
          <td>State can be kept</td>
          <td>Inherently stateless</td>
      </tr>
      <tr>
          <td>Require a host</td>
          <td>Near zero cost to start</td>
      </tr>
  </tbody>
</table>
<p>The operation of these technologies is a significant factor in choosing your architecture, but developer experience is equally important and can seriously impact the long-term success of a project.</p>
<p>Serverless functions and orchestrated containers are both excellent fits for microservice applications, but the planning and development experiences differ greatly. Both are designed to react to load, and both require an understanding of their service platform.</p>
<p>The differences start to emerge when looking at the activities of software development and the structure of the code.</p>
<h3 id="coding-style-orchestrated-containers-vs-serverless-functions">Coding Style: Orchestrated Containers vs. Serverless Functions</h3>
<h4 id="containers">Containers</h4>
<p>Containers are essentially standalone bundles that provide a runtime ready for execution. They abstract the environment away from the operating system so the bundle can be run with familiar runtimes like Flask, ASP.NET, and Spring Boot.</p>
<p>Once you decide the scope of a microservice, developing the code mirrors development on a bare-metal operating system. The migration from development system to datacenter is straightforward and less traumatic.</p>
<h4 id="serverless">Serverless</h4>
<p>Serverless is just that, serverless; no Tomcat, no ASP, no Node. The code exists as a function adrift in the universe of the cloud provider. No need to worry about hardware, OS patching, or hardware failure; you don’t get control of any of that. Zero overhead lets developers focus on development.</p>
<p>Simple applications can be incredibly compact – as little as a few dozen lines of code. This makes serverless incredibly powerful, but this elegant new world is very different to create in.</p>
<p>State has to be maintained outside the function using other cloud services, and data relies on cloud storage. The ability to handle massive scale comes nearly effortlessly, but developing for the serverless environment is a considerable shift in mindset.</p>
<h3 id="platform-knowledge-orchestrated-containers-vs-serverless-functions">Platform Knowledge: Orchestrated Containers vs. Serverless Functions</h3>
<h4 id="containers-1">Containers</h4>
<p>Plan to spend a good deal of time understanding the quirks of your orchestration platform. Kubernetes is well known to be a field of study unto itself, and containers, sidecars, pods, and cluster networking all have to be understood to be used effectively.</p>
<p>You are also responsible for the management of the operating system of your host machines and deciding how much compute resources to dedicate to the cluster to handle load.</p>
<p>There are great tools and knowledge to manage all of these elements, but those do not free you from having to make those decisions and understand the platform.</p>
<h4 id="serverless-1">Serverless</h4>
<p>You live in your cloud, and your cloud platform is the thing that invokes your code. There is no webserver, but you configure an API gateway, there is no file system, but you save to a database or mass storage.</p>
<p>A solid understanding of your cloud provider’s services is essential, and that knowledge is only minimally transferrable to other clouds. Massively capable applications can be built by connecting services together with very little code, but the nuance of those services can be hard to grasp at first.</p>
<h3 id="data-and-state-orchestrated-containers-vs-serverless-functions">Data and State: Orchestrated Containers vs. Serverless Functions</h3>
<h4 id="containers-2">Containers</h4>
<p>You really should write your services to be completely stateless, but you don’t actually have to. You have a hard drive and shared memory at your disposal, and it is feasible to maintain state between processes.</p>
<p>State across a container introduces the risk of really gnarly bugs in race conditions and concurrency and reduces the determinism of how requests are handled. Although total zen-like statelessness is not required, it is strongly desired.</p>
<p>This ability makes it possible to lift older processes with shared state possible, but plan to get out of that soon. Do all of your i/o to shared storage and databases.</p>
<h4 id="serverless-2">Serverless</h4>
<p>As serverless is native to the cloud, reading and writing to the cloud services that complement it is more natural and simpler. Processes are ephemeral, and it is near impossible for stateful things to happen.</p>
<p>This encourages good habits for strict inputs and outputs and even makes separation of concerns more natural.</p>
<p>Cloud providers do allow process orchestration to take place in things like AWS Step Functions and Azure durable functions, which manage state, but those are not to be confused with services like Lambda and Function Apps.</p>
<h3 id="environment-management-orchestrated-containers-vs-serverless-functions">Environment Management: Orchestrated Containers vs. Serverless Functions</h3>
<h4 id="containers-3">Containers</h4>
<p>Managing graduated environments is an essential part of professional software development and container orchestration systems are particularly adept at having naturally separated sandbox, dev, test, UAT, staging, and any other number of environments.</p>
<p>An orchestration cluster operates across multiple computers and can manage a highly flexible number of containers. This makes it simple to build and have a different cluster for each named environment. The separation between the groups is natural and offers a low risk of messages leaking from one environment to another.</p>
<p>Deployments using Helm, Kubectl, or other control tools are well understood and can update software seamlessly with zero downtime.</p>
<h4 id="serverless-3">Serverless</h4>
<p>Environment management is less natural in serverless systems. Every serverless process has a universally unique name and when one service talks to another it needs to know that name. API gateways and DNS can help with this but those are more services to manage and can increase overall complexity when attempting to reduce the logical complexity of the system.</p>
<p>DevOps tools like Terraform, serverless.com, AWS CDK, and Azure Bicep have ways of arranging environments using the concept of ‘stacks’ but this requires an understanding of these tools and the correct use of them.</p>
<p>Overall, there are lots of good ways to create separation between environments. But the technology itself is not opinionated on how to do it, and in many cases, you must be responsible for managing the risk of cross-contamination yourself.</p>
<h3 id="operational-support-orchestrated-containers-vs-serverless-functions">Operational Support: Orchestrated Containers vs. Serverless Functions</h3>
<h4 id="containers-4">Containers</h4>
<p>Kubernetes and its contemporaries are complex systems that require a platform operations team to manage clusters. It is possible to partially get these services with managed Kubernetes services from your cloud provider, but somebody has got to do it.</p>
<p>Containers are best run in integration with a container registry used to store and version container images, and that is one more thing to manage beyond your application code. But debugging containers can be done directly in familiar tools to manage processes, memory, and storage like you do on native hardware.</p>
<h4 id="serverless-4">Serverless</h4>
<p>While you will have a lot less stuff to manage with serverless, being able to tell what is happening in your processes is a very different experience.</p>
<p>Logging and tracing are more important than ever and require that you use your cloud’s native logging tools like CloudWatch or application insights. Debugging is then done through reading logs.</p>
<h4 id="so-which-is-best-orchestrated-containers-or-serverless-functions">So Which is Best: Orchestrated Containers or Serverless Functions?</h4>
<p>Both container orchestration and serverless functions are extremely flexible and powerful tools to build modern applications on top of.</p>
<p>Containers are more like working with VMs or bare metal operating systems and so are more familiar to developers and a more natural fit for incremental improvements in legacy systems.</p>
<p>Serverless functions are more lightweight and more flexible, but this requires developers to think about cloud and service layouts first rather than getting in and coding on day one. This is less natural for many teams and may require a steeper learning curve. But teams that want to invest in ways to move fast and build for the future will benefit greatly.</p>
<p><em>This article was written as part of work I do at AIM Consulting, part of the Addison Group. Its original article can be found at <a href="https://aimconsulting.com/insights/containers-kubernetes-vs-serverless-functions-application-development/">https://aimconsulting.com/insights/containers-kubernetes-vs-serverless-functions-application-development/</a></em></p>

</main>

  <footer>
  <div>&copy; Patrick Taylor</div>

  
  </footer>
  </body>
</html>

